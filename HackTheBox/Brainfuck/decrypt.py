#!/usr/bin/python3 

def egcd(a, b):
    x,y, u,v = 0,1, 1,0
    while a != 0:
        q, r = b//a, b%a
        m, n = x-u*q, y-v*q
        b,a, x,y, u,v = a,r, u,v, m,n
        gcd = b
    return gcd, x, y


def main():

p = 7493025776465062819629921475535241674460826792785520881387158343265274170009282504884941039852933109163193651830303308312565580445669284847225535166520307
q = 7020854527787566735458858381555452648322845008266612906844847937070333480373963284146649074252278753696897245898433245929775591091774274652021374143174079

ct = 44641914821074071930297814589851746700593470770417111804648920018396305246956127337150936081144106405284134845851392541080862652386840869768622438038690803472550278042463029816028777378141217023336710545449512973950591755053735796799773369044083673911035030605581144977552865771395578778515514288930832915182

# Compute n
n = p*q
print(f"P * Q = N: \n{n}\n")

# Compute phi(n)
phi = (p-1)*(q-1)
print(f"(P-1)*(Q-1) = phi: \n{phi}\n")


# Compute modular inverse of e
gcd, a, b = egcd(e, phi)
d = a

#e = ZZ.random_element(phi)
print(f"Random Element testing: {e}")



# Reverse pow() 
# Password is used as base, E as Expression and N is mod
   

    print( "n:  " + str(d) );

    # Decrypt ciphertext
    pt = pow(ct, d, n)
    print( "pt: " + str(pt) )

if __name__ == "__main__":
    main()

