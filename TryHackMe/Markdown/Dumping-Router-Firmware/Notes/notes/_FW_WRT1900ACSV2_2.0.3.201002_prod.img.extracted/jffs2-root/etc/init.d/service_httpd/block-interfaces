#!/bin/sh
#
# Use iptables to block access to selected ports.
#

source /etc/init.d/ulog_functions.sh
source /etc/init.d/event_handler_functions.sh

PROGNAME=$(basename $0)
CONFIG_FILE="/tmp/lighttpd.conf"
GREP_REGEX='\$SERVER\[\"socket\"\] *== *\":[0-9][0-9]*'
SED_REGEX='s/\$SERVER\["socket"\] *== *":\([0-9][0-9]*\)".*/\1/g'
CONF_INTERFACE=$(syscfg get svap_lan_ifname)
VERBOSE=0
LOCAL_INTERFACE="lo"

SERVICE_NAME="firewall"

usage() {
    printf "Usage:\n"
    printf "%s {start|stop|status|list}\n" $PROGNAME
    printf " - start  Installs HTTP blocking entries into iptables\n"
    printf " - stop   Removes HTTP blocking entries into iptables\n"
    printf " - status List firewall rules possibly generated by this program\n"
    printf " - list   List the ports that would be blocked by start\n"
}

if [ "$(type iptables)" == "iptables: not found" ]; then
    echo "$PROGNAME: Firewall not present; exiting."
    exit 0
fi

if [ $# -lt 1 ]; then
    echo "Error: Missing argument"
    usage
    exit 1
fi

if [ -f "$CONFIG_FILE" ]; then
    PORTS=$(grep -i "${GREP_REGEX}" $CONFIG_FILE | \
	grep -v -e 'IGNORE-PORT'| \
        sed "${SED_REGEX}" | \
        sort -n|uniq)
    PORTS=$(echo $PORTS | sed 's/ /,/g')
else
    printf "%s: Error, can't find configuration file \"%s\"\n" \
        "$PROGNAME" "$CONFIG_FILE" >&2
    exit 1
fi

ipt_cmd() {
    # $1 should be either "insert" or "delete"
    local CMD="$1"
    local INT="$2"
    local PORTS="$3"
    local TARGET="$4"
    local INTERFACE_PREFIX="$5"
    local INDEX="$6"

    # We sometimes need to do redundant deletes.  

    /etc/init.d/ipt_run.sh \
    "iptables $CMD INPUT ${INDEX}   \
	--protocol tcp              \
	${INTERFACE_PREFIX} --in-interface $INT \
	-m multiport                \
	--destination-ports $PORTS  \
	--jump $TARGET"
}


block_op() {
    # $1 should be either "insert" or "delete"
    local CMD="--$1"

    # On insert, try to insert after the first rule, allowing accept of
    # related/established flows to match first.  If there's no rule in
    # the INPUT chain, the insert at position two will fail, so retry
    # without a rule index.
    local INDEX=""
    [ "$1" = "insert" ] && INDEX=2

    # svap interface is optional and may not exist
    if [ -n "$CONF_INTERFACE" ];then
        ipt_cmd "$CMD" "$CONF_INTERFACE" "$PORTS" "ACCEPT" "" "$INDEX" ||
            ipt_cmd "$CMD" "$CONF_INTERFACE" "$PORTS" "ACCEPT"
    fi
    ipt_cmd "$CMD" "$LOCAL_INTERFACE" "$PORTS" "ACCEPT" "" "$INDEX" ||
	ipt_cmd "$CMD" "$LOCAL_INTERFACE" "$PORTS" "ACCEPT"
}


case "$1" in
    start)
	wait_till_end_state ${SERVICE_NAME}
	STATUS=$(sysevent get ${SERVICE_NAME}-status)
	if [ "started" = "$STATUS" ] ; then
            # Always delete rule to avoid duplicated statements.
            # iptables lacks a query feature, so there is no 100%
            # reliable way to check for the presence of our rules.
            # Since this may be a needless delete, discard any error
            # output
	    block_op "delete" 2> /dev/null
	    block_op "insert"
	fi
	;;

    stop)
	block_op "delete"
	;;

    list)
	echo $PORTS
	;;
	
    status)
    	HEADER="$(iptables -v --list INPUT -n | head -2)"
    	STATUS_TEXT="$(iptables -v --list INPUT -n | grep "$PORTS")"
	if [ -z "$STATUS_TEXT" ]; then
	    echo "stopped"
	    exit 1
	else
	    echo "rules installed:"
	    echo "$HEADER"
	    echo "$STATUS_TEXT"
	    exit 0
	fi
    	;;

    -h)
	usage
	exit 0
	;;
    *)
	echo "unknown command \"$1\""
	usage
	exit 3
	;;
esac

exit 0
